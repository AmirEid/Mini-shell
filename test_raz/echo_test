echo $""$USER
rpaicminishell $

echo $a $b$c


unset export
==825155== Invalid write of size 1
==825155==    at 0x405207: unset_if_found (unset.c:50)
==825155==    by 0x405062: ft_unset (unset.c:82)
==825155==    by 0x405CC5: ft_execute_routine (execution_routine.c:112)
==825155==    by 0x405AAC: execute_signle_command_line (execution.c:82)
==825155==    by 0x405901: ft_execution (execution.c:112)
==825155==    by 0x407793: main (main.c:72)
==825155==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==825155== 
==825155== 
==825155== Process terminating with default action of signal 11 (SIGSEGV)
==825155==  Access not within mapped region at address 0x0
==825155==    at 0x405207: unset_if_found (unset.c:50)
==825155==    by 0x405062: ft_unset (unset.c:82)
==825155==    by 0x405CC5: ft_execute_routine (execution_routine.c:112)
==825155==    by 0x405AAC: execute_signle_command_line (execution.c:82)
==825155==    by 0x405901: ft_execution (execution.c:112)
==825155==    by 0x407793: main (main.c:72)
==825155==  If you believe this happened as a result of a stack
==825155==  overflow in your program's main thread (unlikely but
==825155==  possible), you can try to increase the size of the
==825155==  main thread stack using the --main-stacksize= flag.
==825155==  The main thread stack size used in this run was 8388608.
==825155== 
==825155== HEAP SUMMARY:
==825155==     in use at exit: 212,267 bytes in 492 blocks
==825155==   total heap usage: 3,633 allocs, 3,141 frees, 358,501 bytes allocated
==825155== 
==825155== LEAK SUMMARY:
==825155==    definitely lost: 61 bytes in 15 blocks
==825155==    indirectly lost: 0 bytes in 0 blocks
==825155==      possibly lost: 0 bytes in 0 blocks
==825155==    still reachable: 212,206 bytes in 477 blocks
==825155==         suppressed: 0 bytes in 0 blocks
==825155== Rerun with --leak-check=full to see details of leaked memory
==825155== 


minishell $ unset PATH
minishell $ /bin/ls
==861276== Invalid read of size 8
==861276==    at 0x408584: get_command (get_command.c:20)
==861276==    by 0x4084E3: define_commands (get_command.c:58)
==861276==    by 0x408EAF: ft_parsing (parsing.c:45)
==861276==    by 0x4077A2: main (main.c:70)
==861276==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==861276== 
==861276== 
==861276== Process terminating with default action of signal 11 (SIGSEGV)
==861276==  Access not within mapped region at address 0x0
==861276==    at 0x408584: get_command (get_command.c:20)
==861276==    by 0x4084E3: define_commands (get_command.c:58)
==861276==    by 0x408EAF: ft_parsing (parsing.c:45)
==861276==    by 0x4077A2: main (main.c:70)
==861276==  If you believe this happened as a result of a stack
==861276==  overflow in your program's main thread (unlikely but
==861276==  possible), you can try to increase the size of the
==861276==  main thread stack using the --main-stacksize= flag.
==861276==  The main thread stack size used in this run was 8388608.
==861276== 
==861276== HEAP SUMMARY:
==861276==     in use at exit: 209,989 bytes in 383 blocks
==861276==   total heap usage: 819 allocs, 436 frees, 241,897 bytes allocated
==861276== 
==861276== LEAK SUMMARY:
==861276==    definitely lost: 0 bytes in 0 blocks
==861276==    indirectly lost: 0 bytes in 0 blocks
==861276==      possibly lost: 0 bytes in 0 blocks
==861276==    still reachable: 209,989 bytes in 383 blocks
==861276==         suppressed: 0 bytes in 0 blocks
==861276== Rerun with --leak-check=full to see details of leaked memory
==861276== 
==861276== For lists of detected and suppressed errors, rerun with: -s
==861276== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
zsh: segmentation fault (core dumped)  valgrind ./minishell



unset USER
unset USER